<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[技术资源 | Workspace of LionHeart]]></title>
  <link href="http://lionheartwang.github.io/blog/categories/技术资源/atom.xml" rel="self"/>
  <link href="http://lionheartwang.github.io/"/>
  <updated>2017-10-24T00:35:56+08:00</updated>
  <id>http://lionheartwang.github.io/</id>
  <author>
    <name><![CDATA[Wang Yiguang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux NFS配置及使用方法]]></title>
    <link href="http://lionheartwang.github.io/blog/2017/10/24/linux-nfs-configuration/"/>
    <updated>2017-10-24T00:27:55+08:00</updated>
    <id>http://lionheartwang.github.io/blog/2017/10/24/linux-nfs-configuration</id>
    <content type="html"><![CDATA[<p>NFS是Network  File System（网络文件系统）。主要功能是通过网络让不同的服务器之间可以共享文件或者目录。</p>

<p>本文以CentOS系统为例介绍Linux下NFS的配置和使用方法。</p>

<p>NFS在文件传送过程中依赖与RPC（远程过程调用）协议，配置步骤介绍如下。</p>

<!-- More -->


<h2>安装软件包</h2>

<p>安装nfs软件包，server和client机器都需要安装</p>

<pre><code class="bash">sudo yum -y install nfs-utils nfs-utils-lib
</code></pre>

<h2>配置NFS Server</h2>

<p>假设用来共享目录的NFS Server机器是192.168.0.1，需要登录该机器配置挂载目录。</p>

<p>登录后编辑/etc/exports文件内容，输入需要挂载的机器IP，以及服务端共享的路径。</p>

<p>假设需要访问NFS共享目录的机器为192.168.0.2 ~ 192.168.0.6，配置/etc/exports如下所示：</p>

<pre><code>/path/to/mount 192.168.0.2(rw,sync,no_root_squash)
/path/to/mount 192.168.0.3(rw,sync,no_root_squash)
/path/to/mount 192.168.0.4(rw,sync,no_root_squash)
/path/to/mount 192.168.0.5(rw,sync,no_root_squash)
/path/to/mount 192.168.0.6(rw,sync,no_root_squash)
...
</code></pre>

<p>其中/path/to/mount根据需要配置为欲挂载的路径即可。</p>

<h2>启动NFS Server</h2>

<p>在192.168.0.1上执行如下命令启动NFS Server</p>

<pre><code class="bash">sudo service rpcbind restart
sudo service nfs restart
</code></pre>

<p>执行如下命令，则会显示挂载的机器IP列表：</p>

<pre><code class="bash">showmount -e 192.168.0.1
</code></pre>

<h2>配置NFS Client</h2>

<p>分别登陆每台需要挂载的client机器，运行如下命令进行共享文件夹挂载。</p>

<pre><code>sudo mkdir /target/to/mount
sudo mount -t nfs 192.168.0.1:/path/to/mount /target/to/mount
</code></pre>

<p>其中：</p>

<ul>
<li>/path/to/mount为之前配置的NFS Server上挂载的路径。</li>
<li>/target/to/mount为本地机器欲挂载到的目标路径。</li>
</ul>


<p>挂载完成后，在192.168.0.2 ~ 192.168.0.6上就可以向访问本地路径一样访问192.168.0.1的/path/to/mount目录了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker常用命令介绍]]></title>
    <link href="http://lionheartwang.github.io/blog/2017/06/18/dockerchang-yong-ming-ling-jie-shao/"/>
    <updated>2017-06-18T22:52:05+08:00</updated>
    <id>http://lionheartwang.github.io/blog/2017/06/18/dockerchang-yong-ming-ling-jie-shao</id>
    <content type="html"><![CDATA[<p>本文介绍常用的docker命令。</p>

<!--more-->


<h2>镜像相关</h2>

<p>查看本地具有的镜像</p>

<pre><code>sudo docker images
</code></pre>

<p>登录远程镜像仓库</p>

<pre><code>docker login &lt;镜像仓库地址&gt;
</code></pre>

<p>例如：</p>

<blockquote><p>docker login test.lionheart.com</p></blockquote>

<p>命名镜像</p>

<pre><code class="bash">docker tag &lt;镜像id&gt; &lt;镜像仓库地址&gt;/&lt;镜像空间名&gt;/&lt;镜像名&gt;:&lt;镜像tag&gt;
</code></pre>

<p>命名镜像后可推送镜像到远端仓库：</p>

<pre><code class="bash">docker push &lt;镜像仓库地址&gt;/&lt;镜像空间名&gt;/&lt;镜像名&gt;:&lt;镜像tag&gt;
</code></pre>

<p>例如：</p>

<blockquote><p>docker tag 12ab34cd56ef test.lionheart.com/wangyiguang/dockertest:1.0</p>

<p>docker push test.lionheart.com/wangyiguang/dockertest:1.0</p></blockquote>

<h2>容器相关</h2>

<p>启动container：</p>

<pre><code class="bash">sudo docker run -tid --name &lt;镜像名&gt; --net=host -l "&lt;资源配置&gt;" &lt;镜像id&gt; /bin/bash
</code></pre>

<p>示例：</p>

<blockquote><p>sudo docker run -tid &ndash;name lionhearttest &ndash;net=host  \</p>

<p>-l &ldquo;GpuCount=1&rdquo; -l &ldquo;PerGpuCache=100000&rdquo; 12ab34cd56ef /bin/bash</p></blockquote>

<p>查看所有container：</p>

<pre><code class="bash">sudo docker ps -a
</code></pre>

<pre><code class="bash">docker tag image_id $image_center_addr/$image_namespace/$IMAGE_NAME:$TAG
</code></pre>

<p>以当前容器创建镜像：</p>

<pre><code class="bash">sudo docker commit &lt;容器id&gt; &lt;镜像名&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用InteliJ远程调试程序]]></title>
    <link href="http://lionheartwang.github.io/blog/2017/04/17/remote-debug-via-intelij/"/>
    <updated>2017-04-17T18:50:33+08:00</updated>
    <id>http://lionheartwang.github.io/blog/2017/04/17/remote-debug-via-intelij</id>
    <content type="html"><![CDATA[<p>本文介绍如何使用InteliJ远程调试Java/Scala程序。</p>

<!--more-->


<h2>以调试模式启动程序</h2>

<p>JVM添加如下启动参数：</p>

<pre><code class="bash">JAVA_DEBUG_OPTS="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=&lt;debugPort&gt;"
java $JAVA_DEBUG_OPTS &lt;className&gt;
</code></pre>

<p>其中：</p>

<ul>
<li>debugPort为调试服务端口，供InteliJ调试器连接，后面会用到。</li>
<li>className为待执行的程序类。</li>
</ul>


<p>启动后会提示如下信息：</p>

<blockquote><p>Listening for transport dt_socket at address: xxxx</p></blockquote>

<h2>调试器远程连接</h2>

<p>在InteliJ菜单选择<code>Run</code> -> <code>Edit Configuration</code>，进入运行配置界面。</p>

<p>选择<code>+</code>添加一项新的配置，内容如下图所示：</p>

<p><img src="/images/blog/04-remoteDebug01.png"></p>

<p>填好配置名称，IP、端口即可。IP、端口要和之前远程启动的程序一致。</p>

<p>然后就可以在源码中设置断点，在InteliJ中进行调试了。</p>

<p><img src="/images/blog/05-remoteDebug02.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac安装Thrift方法]]></title>
    <link href="http://lionheartwang.github.io/blog/2017/03/14/intall-thrift-on-mac/"/>
    <updated>2017-03-14T17:25:31+08:00</updated>
    <id>http://lionheartwang.github.io/blog/2017/03/14/intall-thrift-on-mac</id>
    <content type="html"><![CDATA[<p>新版mac使用brew默认安装的是最新版本的thrift 0.10.1</p>

<p>但现有项目主要依赖0.9.x，因此需要在mac上手动安装thrift。</p>

<p>本文介绍如何在新版本Mac上安装thrift 0.9.3.</p>

<!--more-->


<h2>安装依赖</h2>

<p>确保安装了如下依赖：</p>

<ul>
<li>openssl</li>
<li>libevent</li>
<li>bison 版本> 2.5</li>
</ul>


<p>注意：</p>

<p>mac高版本安装openssl之后可能提示openssl为keg-only的版本</p>

<p>需要记下其安装目录，默认为/usr/local/opt/openssl.</p>

<h2>下载thrift</h2>

<p>以0.9.3为例：</p>

<pre><code class="bash">$wget http://archive.apache.org/dist/thrift/0.9.3/thrift-0.9.3.tar.gz
</code></pre>

<p>下载后解压：</p>

<pre><code class="bash">$tar zxvf thrift-0.9.3.tar.gz
</code></pre>

<h2>编译安装thrift</h2>

<p>运行configure进行配置，注意这里指定了前面记下的openssl的路径：</p>

<pre><code class="bash">$./configure --with-openssl=/usr/local/opt/openssl --without-perl --without-php
</code></pre>

<p>编译：</p>

<pre><code class="bash">$./make
</code></pre>

<p>安装：</p>

<pre><code class="bash">$./make install
</code></pre>

<p>安装后运行：</p>

<pre><code class="bash">$thrift --version
</code></pre>

<p>输出：Thrift version 0.9.3</p>

<p>表明<font color=green><b>安装成功</b></font>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ZooKeeper安装使用指南]]></title>
    <link href="http://lionheartwang.github.io/blog/2017/01/20/zookeeperan-zhuang-shi-yong-zhi-nan/"/>
    <updated>2017-01-20T15:56:22+08:00</updated>
    <id>http://lionheartwang.github.io/blog/2017/01/20/zookeeperan-zhuang-shi-yong-zhi-nan</id>
    <content type="html"><![CDATA[<p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务。</p>

<p>作为分布式应用提供一致性服务的软件，ZooKeeper 封装了易错的关键服务，提供简单高效、功能稳定接口给用户</p>

<p>本文介绍 ZooKeeper 的配置方法和客户端使用方法。</p>

<!--more-->


<h2>ZooKeeper 安装</h2>

<p>以ZooKeeper 3.4.8为例，下载 <a href="http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.8/">ZooKeeper 3.4.8</a>
下载解压后配置conf/zoo.cfg，配置clientPort，dataDir等。
示例配置：</p>

<pre><code class="bash"># The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial synchronization phase can take
initLimit=10
# The number of ticks that can pass between sending a request and getting an acknowledgement
syncLimit=5
# the directory where the snapshot is stored. do not use /tmp for storage, /tmp here is just example sakes.
dataDir=/tmp/zookeeper
# the port at which the clients will connect
clientPort=2181
</code></pre>

<h2>ZooKeeper 使用</h2>

<p>配置好Zk后需要先启动ZkServer，然后可以用Zk Client直接以命令行的方式操作Zk。</p>

<h3>Server端</h3>

<p>配置好后启动zk：</p>

<pre><code class="bash">$sh bin/zkServer.sh start &gt; zookeeper.out
</code></pre>

<h3>Client端</h3>

<p>ZooKeeper客户端的使用非常简单，启动：</p>

<pre><code class="bash"># ip和端口根据启动情况修改
$sh bin/zkCli.sh -server 127.0.0.1:2181
</code></pre>

<p>之后可以用ls、delete、get等命令查询或修改各ZK节点的值。命令帮助如下：</p>

<pre><code>ZooKeeper -server host:port cmd args
    connect host:port
    get path [watch]
    ls path [watch]
    set path data [version]
    rmr path
    delquota [-n|-b] path
    quit
    printwatches on|off
    create [-s] [-e] path data acl
    stat path [watch]
    close
    ls2 path [watch]
    history
    listquota path
    setAcl path acl
    getAcl path
    sync path
    redo cmdno
    addauth scheme auth
    delete path [version]
    setquota -n|-b val path
</code></pre>

<h2>ZooKeeper API</h2>

<p>除了通过客户端操作ZooKeeper，还可以调用ZooKeeper提供的API操作ZooKeeper的节点。</p>

<p>这里以ZooKeeper 3.4.5为例，介绍常用的几个Java API。</p>

<h3>建立连接</h3>

<p>在应用程序中使用Zk需要先创建ZooKeeper对象，后续的操作都是基于该对象进行的。</p>

<pre><code class="java">public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher) throws IOException  
</code></pre>

<p>参数说明：</p>

<ul>
<li>connectString： zookeeper server列表, 以逗号隔开。ZooKeeper对象初始化后, 将从列表中选择一个server, 并尝试建立连接。如果失败,则会从剩余项中选择并再次尝试建立连接。</li>
<li>sessionTimeout：指定连接的超时时间.</li>
<li>watcher： 事件回调接口。</li>
</ul>


<h3>创建/删除znode</h3>

<p>ZooKeeper对象的create/delete方法用于创建/删除 znode。如果该node存在, 则返回该node的状态信息, 否则返回null。</p>

<pre><code class="java">public String create(String path, byte[] data, List acl, CreateMode createMode); 
public void delete(final String path, int version);  
</code></pre>

<p>参数说明：</p>

<ul>
<li>path： znode的路径。</li>
<li>data：与znode关联的数据。</li>
<li>acl：指定权限信息</li>
<li>createMode：指定znode类型，按持久化节点与临时节点，以及自动编号节点与非自动编号节点两个维度划分，共4类。</li>
<li>version：指定要更新的数据的版本, 如果version和真实的版本不同, 更新操作将失败.。指定version为-1则忽略版本检查。</li>
</ul>


<h3>获取子znode列表</h3>

<p>ZooKeeper对象的getChildren方法用于获取子node列表。</p>

<pre><code class="java">public List getChildren(String path, boolean watch); 
</code></pre>

<p>参数说明：</p>

<ul>
<li>path： znode的路径。</li>
<li>watch参数用于指定是否监听path node的创建, 删除事件, 以及数据更新事件。</li>
</ul>


<h3>判断znode是否存在</h3>

<p>ZooKeeper对象的exists方法用于判断指定znode是否存在。如果该node存在, 则返回该node的状态信息, 否则返回null。</p>

<pre><code class="java">public Stat exists(String path, boolean watch);  
</code></pre>

<p>参数说明：</p>

<ul>
<li>path： znode的路径。</li>
<li>watch：用于指定是否监听path node的创建, 删除事件, 以及数据更新事件。</li>
</ul>


<h3>获取/更新znode数据</h3>

<p>ZooKeeper对象的getData/setData方法用于获取/更新 znode关联的数据。</p>

<pre><code class="java">public byte[] getData(String path, boolean watch, Stat stat);  
public Stat setData(final String path, byte data[], int version); 
</code></pre>

<p>参数说明：</p>

<ul>
<li>path： znode的路径。</li>
<li>stat：传出参数, getData方法会将path node的状态信息设置到该参数中。</li>
<li>data：与znode关联的数据。</li>
<li>watch：用于指定是否监听path node的创建, 删除事件, 以及数据更新事件。</li>
<li>version：指定要更新的数据的版本, 如果version和真实的版本不同, 更新操作将失败.。指定version为-1则忽略版本检查。</li>
</ul>


<p>更全的API介绍参考 ZooKeeper 3.4.5 API</p>
]]></content>
  </entry>
  
</feed>
